{"file":"C:\\Users\\Dass\\Desktop\\Master1_YNOV\\DevLogiciel\\biblio\\src\\test\\javascript\\spec\\helpers\\spyobject.ts","mappings":";;;AAWA,MAAa,SAAS;IACpB,YAAY,IAAU;QACpB,IAAI,IAAI,EAAE;YACR,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACzC,IAAI,CAAC,GAAG,IAAI,CAAC;gBACb,IAAI;oBACF,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;iBAC1B;gBAAC,OAAO,CAAC,EAAE;oBACV,gDAAgD;oBAChD,sEAAsE;oBACtE,sDAAsD;oBACtD,qBAAqB;iBACtB;gBACD,IAAI,OAAO,CAAC,KAAK,UAAU,EAAE;oBAC3B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;iBAChB;YACH,CAAC,CAAC,CAAC;SACJ;IACH,CAAC;IAED,GAAG,CAAC,IAAY;QACd,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;SACrD;QACD,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;IACpB,CAAC;IAEO,2BAA2B,CAAC,IAAY;QAC9C,MAAM,MAAM,GAAyB,OAAO,CAAC,SAAS,CAAC,IAAI,CAAQ,CAAC;QACpE,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC,QAAe,CAAC;QAChD,MAAM,CAAC,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,WAAkB,CAAC;QACjD,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAY,CAAC;QACzC,gEAAgE;QAChE,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC7B,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AApCD,8BAoCC","names":[],"sources":["C:\\Users\\Dass\\Desktop\\Master1_YNOV\\DevLogiciel\\biblio\\src\\test\\javascript\\spec\\helpers\\spyobject.ts"],"sourcesContent":["export interface GuinessCompatibleSpy extends jasmine.Spy {\r\n  /** By chaining the spy with and.returnValue, all calls to the function will return a specific\r\n   * value. */\r\n  andReturn(val: any): GuinessCompatibleSpy;\r\n  /** By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied\r\n   * function. */\r\n  andCallFake(fn: Function): GuinessCompatibleSpy;\r\n  /** removes all recorded calls */\r\n  reset(): void;\r\n}\r\n\r\nexport class SpyObject {\r\n  constructor(type?: any) {\r\n    if (type) {\r\n      Object.keys(type.prototype).forEach(prop => {\r\n        let m = null;\r\n        try {\r\n          m = type.prototype[prop];\r\n        } catch (e) {\r\n          // As we are creating spys for abstract classes,\r\n          // these classes might have getters that throw when they are accessed.\r\n          // As we are only auto creating spys for methods, this\r\n          // should not matter.\r\n        }\r\n        if (typeof m === 'function') {\r\n          this.spy(prop);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  spy(name: string): GuinessCompatibleSpy {\r\n    if (!this[name]) {\r\n      this[name] = this.createGuinnessCompatibleSpy(name);\r\n    }\r\n    return this[name];\r\n  }\r\n\r\n  private createGuinnessCompatibleSpy(name: string): GuinessCompatibleSpy {\r\n    const newSpy: GuinessCompatibleSpy = jasmine.createSpy(name) as any;\r\n    newSpy.andCallFake = newSpy.and.callFake as any;\r\n    newSpy.andReturn = newSpy.and.returnValue as any;\r\n    newSpy.reset = newSpy.calls.reset as any;\r\n    // revisit return null here (previously needed for rtts_assert).\r\n    newSpy.and.returnValue(null);\r\n    return newSpy;\r\n  }\r\n}\r\n"],"version":3}